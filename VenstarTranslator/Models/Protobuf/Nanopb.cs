// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: nanopb.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021

namespace Models.Protobuf;

#region Designer generated code

using Protobuf = Google.Protobuf;
using ProtobufReflection = Google.Protobuf.Reflection;
/// <summary>Holder for reflection information generated from nanopb.proto</summary>
public static partial class NanopbReflection {

  #region Descriptor
  /// <summary>File descriptor for nanopb.proto</summary>
  public static ProtobufReflection::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static ProtobufReflection::FileDescriptor descriptor;

  static NanopbReflection() {
    byte[] descriptorData = System.Convert.FromBase64String(
        string.Concat(
          "CgxuYW5vcGIucHJvdG8aEGRlc2NyaXB0b3IucHJvdG8ivAIKDU5hbm9QQk9w",
          "dGlvbnMSEAoIbWF4X3NpemUYASABKAUSEQoJbWF4X2NvdW50GAIgASgFEiYK",
          "CGludF9zaXplGAcgASgOMgguSW50U2l6ZToKSVNfREVGQVVMVBIkCgR0eXBl",
          "GAMgASgOMgouRmllbGRUeXBlOgpGVF9ERUZBVUxUEhgKCmxvbmdfbmFtZXMY",
          "BCABKAg6BHRydWUSHAoNcGFja2VkX3N0cnVjdBgFIAEoCDoFZmFsc2USGgoL",
          "cGFja2VkX2VudW0YCiABKAg6BWZhbHNlEhsKDHNraXBfbWVzc2FnZRgGIAEo",
          "CDoFZmFsc2USGAoJbm9fdW5pb25zGAggASgIOgVmYWxzZRINCgVtc2dpZBgJ",
          "IAEoDRIeCg9hbm9ueW1vdXNfb25lb2YYCyABKAg6BWZhbHNlKloKCUZpZWxk",
          "VHlwZRIOCgpGVF9ERUZBVUxUEAASDwoLRlRfQ0FMTEJBQ0sQARIOCgpGVF9Q",
          "T0lOVEVSEAQSDQoJRlRfU1RBVElDEAISDQoJRlRfSUdOT1JFEAMqRAoHSW50",
          "U2l6ZRIOCgpJU19ERUZBVUxUEAASCAoESVNfOBAIEgkKBUlTXzE2EBASCQoF",
          "SVNfMzIQIBIJCgVJU182NBBAOkUKDm5hbm9wYl9maWxlb3B0EhwuZ29vZ2xl",
          "LnByb3RvYnVmLkZpbGVPcHRpb25zGPIHIAEoCzIOLk5hbm9QQk9wdGlvbnM6",
          "RwoNbmFub3BiX21zZ29wdBIfLmdvb2dsZS5wcm90b2J1Zi5NZXNzYWdlT3B0",
          "aW9ucxjyByABKAsyDi5OYW5vUEJPcHRpb25zOkUKDm5hbm9wYl9lbnVtb3B0",
          "EhwuZ29vZ2xlLnByb3RvYnVmLkVudW1PcHRpb25zGPIHIAEoCzIOLk5hbm9Q",
          "Qk9wdGlvbnM6PgoGbmFub3BiEh0uZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0",
          "aW9ucxjyByABKAsyDi5OYW5vUEJPcHRpb25zQhoKGGZpLmthcHNpLmtvdGku",
          "anBhLm5hbm9wYg=="));
    descriptor = ProtobufReflection::FileDescriptor.FromGeneratedCode(descriptorData,
        new ProtobufReflection::FileDescriptor[] { Google.Protobuf.Reflection.DescriptorReflection.Descriptor, },
        new ProtobufReflection::GeneratedClrTypeInfo(new[] {typeof(FieldType), typeof(IntSize), }, new Protobuf::Extension[] { NanopbExtensions.NanopbFileopt, NanopbExtensions.NanopbMsgopt, NanopbExtensions.NanopbEnumopt, NanopbExtensions.Nanopb }, new ProtobufReflection::GeneratedClrTypeInfo[] {
          new ProtobufReflection::GeneratedClrTypeInfo(typeof(NanoPBOptions), NanoPBOptions.Parser, new[]{ "MaxSize", "MaxCount", "IntSize", "Type", "LongNames", "PackedStruct", "PackedEnum", "SkipMessage", "NoUnions", "Msgid", "AnonymousOneof" }, null, null, null, null)
        }));
  }
  #endregion

}
/// <summary>Holder for extension identifiers generated from the top level of nanopb.proto</summary>
public static partial class NanopbExtensions {
  public static readonly Protobuf::Extension<Google.Protobuf.Reflection.FileOptions, NanoPBOptions> NanopbFileopt =
    new Protobuf::Extension<Google.Protobuf.Reflection.FileOptions, NanoPBOptions>(1010, Protobuf::FieldCodec.ForMessage(8082, NanoPBOptions.Parser));
  public static readonly Protobuf::Extension<Google.Protobuf.Reflection.MessageOptions, NanoPBOptions> NanopbMsgopt =
    new Protobuf::Extension<Google.Protobuf.Reflection.MessageOptions, NanoPBOptions>(1010, Protobuf::FieldCodec.ForMessage(8082, NanoPBOptions.Parser));
  public static readonly Protobuf::Extension<Google.Protobuf.Reflection.EnumOptions, NanoPBOptions> NanopbEnumopt =
    new Protobuf::Extension<Google.Protobuf.Reflection.EnumOptions, NanoPBOptions>(1010, Protobuf::FieldCodec.ForMessage(8082, NanoPBOptions.Parser));
  public static readonly Protobuf::Extension<Google.Protobuf.Reflection.FieldOptions, NanoPBOptions> Nanopb =
    new Protobuf::Extension<Google.Protobuf.Reflection.FieldOptions, NanoPBOptions>(1010, Protobuf::FieldCodec.ForMessage(8082, NanoPBOptions.Parser));
}

#region Enums
public enum FieldType {
  /// <summary>
  /// Automatically decide field type, generate static field if possible.
  /// </summary>
  [ProtobufReflection::OriginalName("FT_DEFAULT")] FtDefault = 0,
  /// <summary>
  /// Always generate a callback field.
  /// </summary>
  [ProtobufReflection::OriginalName("FT_CALLBACK")] FtCallback = 1,
  /// <summary>
  /// Always generate a dynamically allocated field.
  /// </summary>
  [ProtobufReflection::OriginalName("FT_POINTER")] FtPointer = 4,
  /// <summary>
  /// Generate a static field or raise an exception if not possible.
  /// </summary>
  [ProtobufReflection::OriginalName("FT_STATIC")] FtStatic = 2,
  /// <summary>
  /// Ignore the field completely.
  /// </summary>
  [ProtobufReflection::OriginalName("FT_IGNORE")] FtIgnore = 3,
}

public enum IntSize {
  /// <summary>
  /// Default, 32/64bit based on type in .proto
  /// </summary>
  [ProtobufReflection::OriginalName("IS_DEFAULT")] IsDefault = 0,
  [ProtobufReflection::OriginalName("IS_8")] Is8 = 8,
  [ProtobufReflection::OriginalName("IS_16")] Is16 = 16,
  [ProtobufReflection::OriginalName("IS_32")] Is32 = 32,
  [ProtobufReflection::OriginalName("IS_64")] Is64 = 64,
}

#endregion

#region Messages
/// <summary>
/// This is the inner options message, which basically defines options for
/// a field. When it is used in message or file scope, it applies to all
/// fields.
/// </summary>
public sealed partial class NanoPBOptions : Protobuf::IMessage<NanoPBOptions> {
  private static readonly Protobuf::MessageParser<NanoPBOptions> _parser = new Protobuf::MessageParser<NanoPBOptions>(() => new NanoPBOptions());
  private Protobuf::UnknownFieldSet _unknownFields;
  private int _hasBits0;
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static Protobuf::MessageParser<NanoPBOptions> Parser { get { return _parser; } }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static ProtobufReflection::MessageDescriptor Descriptor {
    get { return NanopbReflection.Descriptor.MessageTypes[0]; }
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  ProtobufReflection::MessageDescriptor Protobuf::IMessage.Descriptor {
    get { return Descriptor; }
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public NanoPBOptions() {
    OnConstruction();
  }

  partial void OnConstruction();

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public NanoPBOptions(NanoPBOptions other) : this() {
    _hasBits0 = other._hasBits0;
    maxSize_ = other.maxSize_;
    maxCount_ = other.maxCount_;
    intSize_ = other.intSize_;
    type_ = other.type_;
    longNames_ = other.longNames_;
    packedStruct_ = other.packedStruct_;
    packedEnum_ = other.packedEnum_;
    skipMessage_ = other.skipMessage_;
    noUnions_ = other.noUnions_;
    msgid_ = other.msgid_;
    anonymousOneof_ = other.anonymousOneof_;
    _unknownFields = Protobuf::UnknownFieldSet.Clone(other._unknownFields);
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public NanoPBOptions Clone() {
    return new NanoPBOptions(this);
  }

  /// <summary>Field number for the "max_size" field.</summary>
  public const int MaxSizeFieldNumber = 1;
  private readonly static int MaxSizeDefaultValue = 0;

  private int maxSize_;
  /// <summary>
  /// Allocated size for 'bytes' and 'string' fields.
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MaxSize {
    get { if ((_hasBits0 & 1) != 0) { return maxSize_; } else { return MaxSizeDefaultValue; } }
    set {
      _hasBits0 |= 1;
      maxSize_ = value;
    }
  }
  /// <summary>Gets whether the "max_size" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasMaxSize {
    get { return (_hasBits0 & 1) != 0; }
  }
  /// <summary>Clears the value of the "max_size" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearMaxSize() {
    _hasBits0 &= ~1;
  }

  /// <summary>Field number for the "max_count" field.</summary>
  public const int MaxCountFieldNumber = 2;
  private readonly static int MaxCountDefaultValue = 0;

  private int maxCount_;
  /// <summary>
  /// Allocated number of entries in arrays ('repeated' fields)
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int MaxCount {
    get { if ((_hasBits0 & 2) != 0) { return maxCount_; } else { return MaxCountDefaultValue; } }
    set {
      _hasBits0 |= 2;
      maxCount_ = value;
    }
  }
  /// <summary>Gets whether the "max_count" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasMaxCount {
    get { return (_hasBits0 & 2) != 0; }
  }
  /// <summary>Clears the value of the "max_count" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearMaxCount() {
    _hasBits0 &= ~2;
  }

  /// <summary>Field number for the "int_size" field.</summary>
  public const int IntSizeFieldNumber = 7;
  private readonly static IntSize IntSizeDefaultValue = IntSize.IsDefault;

  private IntSize intSize_;
  /// <summary>
  /// Size of integer fields. Can save some memory if you don't need
  /// full 32 bits for the value.
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public IntSize IntSize {
    get { if ((_hasBits0 & 64) != 0) { return intSize_; } else { return IntSizeDefaultValue; } }
    set {
      _hasBits0 |= 64;
      intSize_ = value;
    }
  }
  /// <summary>Gets whether the "int_size" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasIntSize {
    get { return (_hasBits0 & 64) != 0; }
  }
  /// <summary>Clears the value of the "int_size" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearIntSize() {
    _hasBits0 &= ~64;
  }

  /// <summary>Field number for the "type" field.</summary>
  public const int TypeFieldNumber = 3;
  private readonly static FieldType TypeDefaultValue = FieldType.FtDefault;

  private FieldType type_;
  /// <summary>
  /// Force type of field (callback or static allocation)
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public FieldType Type {
    get { if ((_hasBits0 & 4) != 0) { return type_; } else { return TypeDefaultValue; } }
    set {
      _hasBits0 |= 4;
      type_ = value;
    }
  }
  /// <summary>Gets whether the "type" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasType {
    get { return (_hasBits0 & 4) != 0; }
  }
  /// <summary>Clears the value of the "type" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearType() {
    _hasBits0 &= ~4;
  }

  /// <summary>Field number for the "long_names" field.</summary>
  public const int LongNamesFieldNumber = 4;
  private readonly static bool LongNamesDefaultValue = true;

  private bool longNames_;
  /// <summary>
  /// Use long names for enums, i.e. EnumName_EnumValue.
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool LongNames {
    get { if ((_hasBits0 & 8) != 0) { return longNames_; } else { return LongNamesDefaultValue; } }
    set {
      _hasBits0 |= 8;
      longNames_ = value;
    }
  }
  /// <summary>Gets whether the "long_names" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasLongNames {
    get { return (_hasBits0 & 8) != 0; }
  }
  /// <summary>Clears the value of the "long_names" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearLongNames() {
    _hasBits0 &= ~8;
  }

  /// <summary>Field number for the "packed_struct" field.</summary>
  public const int PackedStructFieldNumber = 5;
  private readonly static bool PackedStructDefaultValue = false;

  private bool packedStruct_;
  /// <summary>
  /// Add 'packed' attribute to generated structs.
  /// Note: this cannot be used on CPUs that break on unaligned
  /// accesses to variables.
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool PackedStruct {
    get { if ((_hasBits0 & 16) != 0) { return packedStruct_; } else { return PackedStructDefaultValue; } }
    set {
      _hasBits0 |= 16;
      packedStruct_ = value;
    }
  }
  /// <summary>Gets whether the "packed_struct" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasPackedStruct {
    get { return (_hasBits0 & 16) != 0; }
  }
  /// <summary>Clears the value of the "packed_struct" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearPackedStruct() {
    _hasBits0 &= ~16;
  }

  /// <summary>Field number for the "packed_enum" field.</summary>
  public const int PackedEnumFieldNumber = 10;
  private readonly static bool PackedEnumDefaultValue = false;

  private bool packedEnum_;
  /// <summary>
  /// Add 'packed' attribute to generated enums.
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool PackedEnum {
    get { if ((_hasBits0 & 512) != 0) { return packedEnum_; } else { return PackedEnumDefaultValue; } }
    set {
      _hasBits0 |= 512;
      packedEnum_ = value;
    }
  }
  /// <summary>Gets whether the "packed_enum" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasPackedEnum {
    get { return (_hasBits0 & 512) != 0; }
  }
  /// <summary>Clears the value of the "packed_enum" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearPackedEnum() {
    _hasBits0 &= ~512;
  }

  /// <summary>Field number for the "skip_message" field.</summary>
  public const int SkipMessageFieldNumber = 6;
  private readonly static bool SkipMessageDefaultValue = false;

  private bool skipMessage_;
  /// <summary>
  /// Skip this message
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool SkipMessage {
    get { if ((_hasBits0 & 32) != 0) { return skipMessage_; } else { return SkipMessageDefaultValue; } }
    set {
      _hasBits0 |= 32;
      skipMessage_ = value;
    }
  }
  /// <summary>Gets whether the "skip_message" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasSkipMessage {
    get { return (_hasBits0 & 32) != 0; }
  }
  /// <summary>Clears the value of the "skip_message" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearSkipMessage() {
    _hasBits0 &= ~32;
  }

  /// <summary>Field number for the "no_unions" field.</summary>
  public const int NoUnionsFieldNumber = 8;
  private readonly static bool NoUnionsDefaultValue = false;

  private bool noUnions_;
  /// <summary>
  /// Generate oneof fields as normal optional fields instead of union.
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool NoUnions {
    get { if ((_hasBits0 & 128) != 0) { return noUnions_; } else { return NoUnionsDefaultValue; } }
    set {
      _hasBits0 |= 128;
      noUnions_ = value;
    }
  }
  /// <summary>Gets whether the "no_unions" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasNoUnions {
    get { return (_hasBits0 & 128) != 0; }
  }
  /// <summary>Clears the value of the "no_unions" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearNoUnions() {
    _hasBits0 &= ~128;
  }

  /// <summary>Field number for the "msgid" field.</summary>
  public const int MsgidFieldNumber = 9;
  private readonly static uint MsgidDefaultValue = 0;

  private uint msgid_;
  /// <summary>
  /// integer type tag for a message
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public uint Msgid {
    get { if ((_hasBits0 & 256) != 0) { return msgid_; } else { return MsgidDefaultValue; } }
    set {
      _hasBits0 |= 256;
      msgid_ = value;
    }
  }
  /// <summary>Gets whether the "msgid" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasMsgid {
    get { return (_hasBits0 & 256) != 0; }
  }
  /// <summary>Clears the value of the "msgid" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearMsgid() {
    _hasBits0 &= ~256;
  }

  /// <summary>Field number for the "anonymous_oneof" field.</summary>
  public const int AnonymousOneofFieldNumber = 11;
  private readonly static bool AnonymousOneofDefaultValue = false;

  private bool anonymousOneof_;
  /// <summary>
  /// decode oneof as anonymous union
  /// </summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool AnonymousOneof {
    get { if ((_hasBits0 & 1024) != 0) { return anonymousOneof_; } else { return AnonymousOneofDefaultValue; } }
    set {
      _hasBits0 |= 1024;
      anonymousOneof_ = value;
    }
  }
  /// <summary>Gets whether the "anonymous_oneof" field is set</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool HasAnonymousOneof {
    get { return (_hasBits0 & 1024) != 0; }
  }
  /// <summary>Clears the value of the "anonymous_oneof" field</summary>
  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearAnonymousOneof() {
    _hasBits0 &= ~1024;
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other) {
    return Equals(other as NanoPBOptions);
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(NanoPBOptions other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (MaxSize != other.MaxSize) return false;
    if (MaxCount != other.MaxCount) return false;
    if (IntSize != other.IntSize) return false;
    if (Type != other.Type) return false;
    if (LongNames != other.LongNames) return false;
    if (PackedStruct != other.PackedStruct) return false;
    if (PackedEnum != other.PackedEnum) return false;
    if (SkipMessage != other.SkipMessage) return false;
    if (NoUnions != other.NoUnions) return false;
    if (Msgid != other.Msgid) return false;
    if (AnonymousOneof != other.AnonymousOneof) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode() {
    int hash = 1;
    if (HasMaxSize) hash ^= MaxSize.GetHashCode();
    if (HasMaxCount) hash ^= MaxCount.GetHashCode();
    if (HasIntSize) hash ^= IntSize.GetHashCode();
    if (HasType) hash ^= Type.GetHashCode();
    if (HasLongNames) hash ^= LongNames.GetHashCode();
    if (HasPackedStruct) hash ^= PackedStruct.GetHashCode();
    if (HasPackedEnum) hash ^= PackedEnum.GetHashCode();
    if (HasSkipMessage) hash ^= SkipMessage.GetHashCode();
    if (HasNoUnions) hash ^= NoUnions.GetHashCode();
    if (HasMsgid) hash ^= Msgid.GetHashCode();
    if (HasAnonymousOneof) hash ^= AnonymousOneof.GetHashCode();
    if (_unknownFields != null) {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString() {
    return Protobuf::JsonFormatter.ToDiagnosticString(this);
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(Protobuf::CodedOutputStream output) {
    if (HasMaxSize) {
      output.WriteRawTag(8);
      output.WriteInt32(MaxSize);
    }
    if (HasMaxCount) {
      output.WriteRawTag(16);
      output.WriteInt32(MaxCount);
    }
    if (HasType) {
      output.WriteRawTag(24);
      output.WriteEnum((int) Type);
    }
    if (HasLongNames) {
      output.WriteRawTag(32);
      output.WriteBool(LongNames);
    }
    if (HasPackedStruct) {
      output.WriteRawTag(40);
      output.WriteBool(PackedStruct);
    }
    if (HasSkipMessage) {
      output.WriteRawTag(48);
      output.WriteBool(SkipMessage);
    }
    if (HasIntSize) {
      output.WriteRawTag(56);
      output.WriteEnum((int) IntSize);
    }
    if (HasNoUnions) {
      output.WriteRawTag(64);
      output.WriteBool(NoUnions);
    }
    if (HasMsgid) {
      output.WriteRawTag(72);
      output.WriteUInt32(Msgid);
    }
    if (HasPackedEnum) {
      output.WriteRawTag(80);
      output.WriteBool(PackedEnum);
    }
    if (HasAnonymousOneof) {
      output.WriteRawTag(88);
      output.WriteBool(AnonymousOneof);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(output);
    }
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize() {
    int size = 0;
    if (HasMaxSize) {
      size += 1 + Protobuf::CodedOutputStream.ComputeInt32Size(MaxSize);
    }
    if (HasMaxCount) {
      size += 1 + Protobuf::CodedOutputStream.ComputeInt32Size(MaxCount);
    }
    if (HasIntSize) {
      size += 1 + Protobuf::CodedOutputStream.ComputeEnumSize((int) IntSize);
    }
    if (HasType) {
      size += 1 + Protobuf::CodedOutputStream.ComputeEnumSize((int) Type);
    }
    if (HasLongNames) {
      size += 1 + 1;
    }
    if (HasPackedStruct) {
      size += 1 + 1;
    }
    if (HasPackedEnum) {
      size += 1 + 1;
    }
    if (HasSkipMessage) {
      size += 1 + 1;
    }
    if (HasNoUnions) {
      size += 1 + 1;
    }
    if (HasMsgid) {
      size += 1 + Protobuf::CodedOutputStream.ComputeUInt32Size(Msgid);
    }
    if (HasAnonymousOneof) {
      size += 1 + 1;
    }
    if (_unknownFields != null) {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(NanoPBOptions other) {
    if (other == null) {
      return;
    }
    if (other.HasMaxSize) {
      MaxSize = other.MaxSize;
    }
    if (other.HasMaxCount) {
      MaxCount = other.MaxCount;
    }
    if (other.HasIntSize) {
      IntSize = other.IntSize;
    }
    if (other.HasType) {
      Type = other.Type;
    }
    if (other.HasLongNames) {
      LongNames = other.LongNames;
    }
    if (other.HasPackedStruct) {
      PackedStruct = other.PackedStruct;
    }
    if (other.HasPackedEnum) {
      PackedEnum = other.PackedEnum;
    }
    if (other.HasSkipMessage) {
      SkipMessage = other.SkipMessage;
    }
    if (other.HasNoUnions) {
      NoUnions = other.NoUnions;
    }
    if (other.HasMsgid) {
      Msgid = other.Msgid;
    }
    if (other.HasAnonymousOneof) {
      AnonymousOneof = other.AnonymousOneof;
    }
    _unknownFields = Protobuf::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Protobuf::CodedInputStream input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
      switch(tag) {
        default:
          _unknownFields = Protobuf::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8: {
          MaxSize = input.ReadInt32();
          break;
        }
        case 16: {
          MaxCount = input.ReadInt32();
          break;
        }
        case 24: {
          Type = (FieldType) input.ReadEnum();
          break;
        }
        case 32: {
          LongNames = input.ReadBool();
          break;
        }
        case 40: {
          PackedStruct = input.ReadBool();
          break;
        }
        case 48: {
          SkipMessage = input.ReadBool();
          break;
        }
        case 56: {
          IntSize = (IntSize) input.ReadEnum();
          break;
        }
        case 64: {
          NoUnions = input.ReadBool();
          break;
        }
        case 72: {
          Msgid = input.ReadUInt32();
          break;
        }
        case 80: {
          PackedEnum = input.ReadBool();
          break;
        }
        case 88: {
          AnonymousOneof = input.ReadBool();
          break;
        }
      }
    }
  }

}

#endregion


#endregion Designer generated code
